## 1.定点数一位乘法

### 1.1定点原码一位乘法

原码相乘，积符号同号得正、异号得负，数值为两数绝对值之积。

> 例：X=0.1101，Y=0.1011，求两数之积
>
> 解：取双符号位
>
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/20201121162200336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU3MTg4Ng==,size_16,color_FFFFFF,t_70#pic_center)

>
> 部分积右移时，乘数寄存器同时右移一位。计算用两位符号，结果保留一位符号。
>
> X*Y=0.10001111
>
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/20201121162250835.png#pic_center)

> C~d~是乘数位数的补码值，每计算一次减一次。
>
> C~n~是C寄存器中Y的最低位，为1则部分积加X，为0则部分积加0。

### 1.2定点补码一位乘法

被乘数 [X]~补~=X~0~.X~1~X~2~...X~n~，乘数 [Y]~补~=Y~0~.Y~1~Y~2~...Y~n~

==[X* Y]~补~=[X]~补~（0.Y~1~Y~2~...Y~n~)-[X]~补~* Y~0~==

Y~0~=1即Y为负数时，需要补充-[X]~补~* Y~0~这一项，Y~0~=0即Y为正数时，不用这一项。剩下步骤和定点一位乘法一样，右移带符号。

**布斯公式**

==[X * Y]~补~=[X]~补~ * (-Y~0~+Y~1~2^-1^+Y~2~2^-2^+...+Y~n~2^-n^)=[X]~补*~$\sum_{i=1}^n (Yi+1-Y~i~)2^i$==

Y~i+1~与Y~i~为相邻两位，(Y~i+1~-Y~i~)有0，1和-1三种情况，其运算规则如下：

- (1) Y~i+1~-Y~i~=0(Y~i+1~Y~i~=00或11)，部分积加0，右移1位。

- (2) Y~i+1~-Y~i~=1(Y~i+1~Y~i~=10)，部分积加[X]~补~，右移1位。

- (3) Y~i+1~-Y~i~=-1(Y~i+1~Y~i~=01)，部分积加[-X]~补~，右移1位.

- 最后一步(i=n+1)不移位。

### 1.3定点原码二位乘法

乘数都用原码，两位乘数有四种组合：

> 00：0*X。部分积P~I~右移两位。
>
> 01：1*X。部分积P~i~+X，右移两位。
>
> 10：2*X。部分积P~i~+2X，右移两位。
>
> 11：3*X。部分积P~i~-X+4X，右移两位。

原码两位乘法规则表

| Y~I-1~ | Y~I~ | C    | 操作            | 操作 |
| ------ | ---- | ---- | --------------- | ---- |
| 0      | 0    | 0    | （P~I~+0)2^-2^  | 0->C |
| 0      | 0    | 1    | （P~I~+X)2^-2^  | 0->C |
| 0      | 1    | 0    | （P~I~+X)2^-2^  | 0->C |
| 0      | 1    | 1    | （P~I~+2X)2^-2^ | 0->C |
| 1      | 0    | 0    | （P~I~+2X)2^-2^ | 0->C |
| 1      | 0    | 1    | （P~I~-X)2^-2^  | 1->C |
| 1      | 1    | 0    | （P~I~-X)2^-2^  | 1->C |
| 1      | 1    | 1    | （P~I~+0)2^-2^  | 1->C |

若最后一次操作欠下+4X，则最后一次右移两位后还应补充+X操作，且不再移位。

### 1.4定点补码二位乘法

| Y~n-i-1~ | Y~n-i~ | Y~n-i+1~ | 组合值 | [p~i+2~]~补~                |
| -------- | ------ | -------- | ------ | --------------------------- |
| 0        | 0      | 0        | 0      | （[P~I~]~补~+0)2^-2^        |
| 0        | 0      | 1        | 1      | （[P~I~]~补~+[X]~补~)2^-2^  |
| 0        | 1      | 0        | 1      | （[P~I~]~补~+[X]~补~)2^-2^  |
| 0        | 1      | 1        | 2      | （[P~I~]~补~+2[X]~补~)2^-2^ |
| 1        | 0      | 0        | -2     | （[P~I~]~补~+2[X]~补~)2^-2^ |
| 1        | 0      | 1        | -1     | （[P~I~]~补~-[X]~补~)2^-2^  |
| 1        | 1      | 0        | -1     | （[P~I~]~补~-[X]~补~)2^-2^  |
| 1        | 1      | 1        | 0      | （[P~I~]~补~+0)2^-2^        |

## 2.浮点数加减法运算

X=M~X~*2^Ex^,  Y=M~Y~*2^Ey^，均为规格化数。

1. 对阶

> 求出$$delta(E)$$=E~X~-E~Y~,保留大的那个，将小的那个的尾数右移delta(E)位，使X和Y阶码相等，过程中原码表示的符号位不移位，补0；补码表示的尾数保持符号位不变。

2. 尾数加减

> 对阶后，尾数进行运算。

3. 规格化

> 使尾数绝对值以最大值形式出现。
>
> 双符号原码规格化尾数：00.1xxxxx或11.1xxxxx
>
> 双符号补码规格化尾数：00.1xxxxx或11.0xxxxx
>
> 规则：
>
> > 1. 若结果的两符号位不同，表示溢出，尾数右移1位，阶码加1，“右规”。
> > 2. 若结果两符号位相同，表示不溢出，若最高数值位和符号位同，尾数连续左移，until不同，阶码减去移位数，“左规”。

4. 舍入

右规或对阶时，尾数低位的数值会失去，为提高精度，采取==0舍1入==。

5. 检查阶码是否溢出

阶码溢出表示浮点数溢出。在三四步都可能溢出。

> 若正常，end；
>
> 若下溢，置机器零；
>
> 若上溢，则OF=1。

